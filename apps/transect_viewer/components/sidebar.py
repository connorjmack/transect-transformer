"""Sidebar component for file loading and navigation."""

from pathlib import Path

import streamlit as st

from apps.transect_viewer import config
from apps.transect_viewer.utils.data_loader import (
    load_npz,
    load_npz_from_upload,
    get_all_transect_ids,
    get_cube_dimensions,
    get_epoch_dates,
    is_cube_format,
)
from apps.transect_viewer.utils.helpers import safe_epoch_option


def render_sidebar() -> str:
    """
    Render the sidebar with file loading and view selection.

    Returns:
        Selected view mode string
    """
    st.sidebar.title("CliffCast Viewer")

    # View mode selection (at top for easy access)
    view_mode = st.sidebar.selectbox(
        "View",
        config.VIEW_MODES,
        label_visibility="collapsed",
    )

    st.sidebar.markdown("---")

    # File loading section
    st.sidebar.header("Data Loading")

    # Option 1: File uploader
    uploaded_file = st.sidebar.file_uploader(
        "Upload NPZ file",
        type=["npz"],
        help="Upload a transect NPZ file generated by extract_transects.py"
    )

    # Option 2: Path input
    st.sidebar.markdown("**Or enter file path:**")
    file_path = st.sidebar.text_input(
        "NPZ file path",
        value=config.DEFAULT_DATA_PATH,
        label_visibility="collapsed",
    )

    # Load button
    col1, col2 = st.sidebar.columns(2)

    with col1:
        if st.button("Load File", use_container_width=True):
            _load_from_path(file_path)

    with col2:
        if st.button("Clear Data", use_container_width=True):
            _clear_data()

    # Handle uploaded file
    if uploaded_file is not None:
        if st.session_state.current_file != uploaded_file.name:
            _load_from_upload(uploaded_file)

    # Show loaded data info
    _render_data_info()

    # View-specific options
    _render_view_options(view_mode)

    return view_mode


def _load_from_path(file_path: str):
    """Load data from file path."""
    path = Path(file_path)

    if not path.exists():
        st.sidebar.error(f"File not found: {file_path}")
        return

    try:
        with st.spinner("Loading data..."):
            data = load_npz(str(path))
            st.session_state.data = data
            st.session_state.current_file = path.name

            # Set default transect ID
            transect_ids = get_all_transect_ids(data)
            if transect_ids:
                st.session_state.selected_transect_id = transect_ids[0]

            # Set default epoch index (latest)
            dims = get_cube_dimensions(data)
            st.session_state.selected_epoch_idx = dims['n_epochs'] - 1

        st.sidebar.success(f"Loaded: {path.name}")
    except Exception as e:
        st.sidebar.error(f"Error loading file: {e}")


def _load_from_upload(uploaded_file):
    """Load data from uploaded file."""
    try:
        with st.spinner("Loading uploaded file..."):
            data = load_npz_from_upload(uploaded_file)
            st.session_state.data = data
            st.session_state.current_file = uploaded_file.name

            # Set default transect ID
            transect_ids = get_all_transect_ids(data)
            if transect_ids:
                st.session_state.selected_transect_id = transect_ids[0]

            # Set default epoch index (latest)
            dims = get_cube_dimensions(data)
            st.session_state.selected_epoch_idx = dims['n_epochs'] - 1

        st.sidebar.success(f"Loaded: {uploaded_file.name}")
    except Exception as e:
        st.sidebar.error(f"Error loading file: {e}")


def _clear_data():
    """Clear all loaded data."""
    st.session_state.data = None
    st.session_state.selected_transect_id = None
    st.session_state.selected_transects = []
    st.session_state.current_file = None
    st.session_state.selected_epoch_idx = 0
    st.rerun()


def _render_data_info():
    """Render information about loaded data."""
    if st.session_state.data is None:
        st.sidebar.info("No data loaded")
        return

    data = st.session_state.data

    st.sidebar.markdown("---")
    st.sidebar.subheader("Loaded Data")

    # Get cube dimensions
    dims = get_cube_dimensions(data)
    is_cube = is_cube_format(data)

    st.sidebar.metric("Transects", dims['n_transects'])
    st.sidebar.metric("Points/Transect", dims['n_points'])
    st.sidebar.metric("Features", dims['n_features'])

    # Show temporal info for cube format
    if is_cube:
        st.sidebar.metric("Temporal Epochs", dims['n_epochs'])
    else:
        st.sidebar.info("Flat format (single epoch)")


def _render_view_options(view_mode: str):
    """Render view-specific options in sidebar."""
    if st.session_state.data is None:
        return

    st.sidebar.markdown("---")
    st.sidebar.subheader("View Options")

    data = st.session_state.data
    dims = get_cube_dimensions(data)
    is_cube = is_cube_format(data)

    if view_mode == "Single Transect Inspector":
        # Transect selector
        transect_ids = get_all_transect_ids(data)

        selected_id = st.sidebar.selectbox(
            "Transect ID",
            transect_ids,
            index=transect_ids.index(st.session_state.selected_transect_id)
            if st.session_state.selected_transect_id in transect_ids
            else 0,
        )
        st.session_state.selected_transect_id = selected_id

        # Epoch selector (for cube format)
        if is_cube and dims['n_epochs'] > 1:
            epoch_dates = get_epoch_dates(data)
            epoch_options = [safe_epoch_option(epoch_dates, i) for i in range(dims['n_epochs'])]

            selected_epoch = st.sidebar.selectbox(
                "Epoch",
                range(dims['n_epochs']),
                index=st.session_state.selected_epoch_idx,
                format_func=lambda x: epoch_options[x] if x < len(epoch_options) else f"Epoch {x}",
            )
            st.session_state.selected_epoch_idx = selected_epoch

        # Feature selector
        feature_names = data.get('feature_names', [])
        if isinstance(feature_names, list) and feature_names:
            selected_feature = st.sidebar.selectbox(
                "Primary Feature",
                feature_names,
                index=feature_names.index(st.session_state.selected_feature)
                if st.session_state.selected_feature in feature_names
                else 0,
            )
            st.session_state.selected_feature = selected_feature

    elif view_mode == "Transect Evolution":
        # Transect selector for evolution view
        transect_ids = get_all_transect_ids(data)

        selected_id = st.sidebar.selectbox(
            "Transect ID",
            transect_ids,
            index=transect_ids.index(st.session_state.selected_transect_id)
            if st.session_state.selected_transect_id in transect_ids
            else 0,
            key="evolution_transect_id",
        )
        st.session_state.selected_transect_id = selected_id

        if not is_cube or dims['n_epochs'] < 2:
            st.sidebar.warning("Temporal data requires cube format with multiple epochs")

    elif view_mode == "Forcing Timeseries":
        # Transect selector for forcing view
        transect_ids = get_all_transect_ids(data)

        selected_id = st.sidebar.selectbox(
            "Transect ID",
            transect_ids,
            index=transect_ids.index(st.session_state.selected_transect_id)
            if st.session_state.selected_transect_id in transect_ids
            else 0,
            key="forcing_transect_id",
        )
        st.session_state.selected_transect_id = selected_id

    elif view_mode == "Cross-Transect View":
        # Epoch selector for cross-transect view
        if is_cube and dims['n_epochs'] > 1:
            epoch_dates = get_epoch_dates(data)
            epoch_options = [safe_epoch_option(epoch_dates, i) for i in range(dims['n_epochs'])]

            selected_epoch = st.sidebar.selectbox(
                "Epoch to Display",
                range(dims['n_epochs']),
                index=st.session_state.selected_epoch_idx,
                format_func=lambda x: epoch_options[x] if x < len(epoch_options) else f"Epoch {x}",
                key="cross_transect_epoch",
            )
            st.session_state.selected_epoch_idx = selected_epoch

        # Metadata field selector for map coloring
        metadata_names = data.get('metadata_names', [])
        if isinstance(metadata_names, list) and metadata_names:
            st.sidebar.selectbox(
                "Color map by",
                metadata_names,
                index=0,
                key="map_color_field",
            )
